<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ani - Complete Voice Companion</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Poppins:wght@300;400;600&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Poppins', 'Segoe UI', Arial, sans-serif;
            background: #0a0a0a;
            overflow: hidden;
            color: white;
        }

        /* Simple animated gradient background */
        #bg-gradient {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            background: linear-gradient(-45deg, #0f0c29, #302b63, #24243e, #764ba2);
            background-size: 400% 400%;
            animation: gradientShift 20s ease infinite;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        #canvas-container { width: 100vw; height: 100vh; position: relative; z-index: 1; }

        /* Logo */
        #logo {
            position: absolute;
            top: 20px;
            left: 20px;
            font-family: 'Orbitron', monospace;
            z-index: 100;
        }
        .logo-main {
            font-size: 32px;
            font-weight: 900;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 2px;
            text-shadow: 0 0 30px rgba(102, 126, 234, 0.5);
        }
        .logo-sub {
            font-size: 10px;
            font-weight: 400;
            opacity: 0.7;
            margin-top: -5px;
            letter-spacing: 3px;
        }
        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 12, 41, 0.85);
            padding: 20px 40px;
            border-radius: 60px;
            display: flex;
            gap: 15px;
            align-items: center;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(102, 126, 234, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        button {
            padding: 14px 32px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 30px;
            color: white;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'Poppins', sans-serif;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            position: relative;
            overflow: hidden;
        }
        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        button:hover::before {
            width: 300px;
            height: 300px;
        }
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 25px rgba(102, 126, 234, 0.6);
        }
        button.recording {
            background: linear-gradient(135deg, #f44336, #e91e63);
            animation: pulse 1.5s infinite;
            box-shadow: 0 4px 20px rgba(244, 67, 54, 0.5);
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 4px 20px rgba(244, 67, 54, 0.5); }
            50% { transform: scale(1.05); box-shadow: 0 6px 30px rgba(244, 67, 54, 0.8); }
        }
        #status {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(15, 12, 41, 0.8);
            padding: 12px 20px;
            border-radius: 20px;
            font-size: 13px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(102, 126, 234, 0.2);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        .status-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-connected { background: #4CAF50; }
        .status-disconnected { background: #f44336; }
        .status-thinking { background: #FFC107; }
        #emotion-display {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(15, 12, 41, 0.8);
            padding: 18px 28px;
            border-radius: 20px;
            backdrop-filter: blur(20px);
            min-width: 160px;
            border: 1px solid rgba(102, 126, 234, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }
        #debug-panel {
            position: absolute;
            bottom: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 15px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 11px;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }
        .debug-line {
            margin: 2px 0;
            color: #0f0;
        }
        .emotion-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }
        .emotion-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }
        .emotion-icon {
            display: inline-block;
            margin-right: 8px;
            font-size: 20px;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 24px;
            font-weight: 600;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Background -->
    <div id="bg-gradient"></div>

    <div id="canvas-container"></div>

    <!-- Logo -->
    <div id="logo">
        <div class="logo-main">ANITA</div>
        <div class="logo-sub">BY JOHNNY LIU</div>
    </div>

    <div id="loading"><div class="spinner"></div>Loading Ani...</div>
    <div id="status" style="display: none;">
        <span class="status-dot status-disconnected"></span>
        <span id="status-text">Disconnected</span>
    </div>
    <div id="emotion-display" style="display: none;">
        <div style="opacity: 0.7; font-size: 12px; margin-bottom: 5px;">Emotion</div>
        <div>
            <span class="emotion-icon" id="emotion-icon">üòä</span>
            <span id="emotion-text">Neutral</span>
        </div>
        <div class="emotion-bar">
            <div class="emotion-bar-fill" id="emotion-bar-fill"></div>
        </div>
    </div>
    <div id="controls" style="display: none;">
        <button id="talk-btn">Hold to Talk</button>
        <span id="mic-status" style="font-size: 12px; opacity: 0.7;">Click and speak</span>
    </div>
    <div id="debug-panel" style="display: none;">
        <div style="color: #fff; margin-bottom: 5px; font-weight: bold;">üîß Debug</div>
        <div class="debug-line">Gesture: <span id="debug-gesture">none</span></div>
        <div class="debug-line">Progress: <span id="debug-progress">0.00</span></div>
        <div class="debug-line">R-Arm: <span id="debug-rarm">0, 0, 0</span></div>
        <div class="debug-line">L-Arm: <span id="debug-larm">0, 0, 0</span></div>
        <div class="debug-line">Head: <span id="debug-head">0, 0, 0</span></div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/",
            "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3.1.2/lib/three-vrm.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { VRMLoaderPlugin } from '@pixiv/three-vrm';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Global state
        let scene, camera, renderer, controls, vrm;
        let ws = null;
        let recognition = null;
        let isListening = false;
        let currentAudio = null;
        const clock = new THREE.Clock();
        let time = 0;

        // Expression transition state
        let currentExpression = { emotion: 'neutral', intensity: 0 };
        let targetExpression = { emotion: 'neutral', intensity: 0 };
        let expressionTransitionProgress = 1.0;
        const EXPRESSION_TRANSITION_SPEED = 3.0; // transitions per second

        // Blink system
        let lastBlinkTime = 0;
        let nextBlinkDelay = 3.0;
        let isBlinking = false;
        let blinkProgress = 0;

        const EMOTION_MAP = {
            'joy': 'happy',
            'sad': 'sad',
            'anger': 'angry',
            'surprise': 'surprised',
            'neutral': 'neutral',
            'excited': 'happy',      // Map to happy with higher intensity
            'confused': 'surprised', // Map to surprised
            'embarrassed': 'happy',  // Shy smile
            'determined': 'neutral', // Focused expression
            'relaxed': 'relaxed'
        };

        // ÂàùÂßãÂåñÂú∫ÊôØ
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x212121);

        camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1.4, 3);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // ÁÅØÂÖâ
        const light1 = new THREE.DirectionalLight(0xffffff, 1.5);
        light1.position.set(1, 1, 1);
        scene.add(light1);

        const light2 = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(light2);

        const rimLight = new THREE.DirectionalLight(0x667eea, 0.5);
        rimLight.position.set(-1, 1, -1);
        scene.add(rimLight);

        // ÊéßÂà∂Âô®
        controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1.2, 0);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.update();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Âä†ËΩΩVRM
        const loader = new GLTFLoader();
        loader.register((parser) => new VRMLoaderPlugin(parser));

        loader.load('/character/darkhair.vrm', (gltf) => {
            vrm = gltf.userData.vrm;
            scene.add(vrm.scene);
            vrm.scene.rotation.y = Math.PI;

            console.log('[OK] VRM loaded');

            if (vrm.humanoid) {
                // ËÆæÁΩÆÂàùÂßãÂßøÂäø - ‰ΩøÁî® rotation.set() ËÄå‰∏çÊòØÂàÜÂà´ËÆæÁΩÆ x/y/z
                const leftArm = vrm.humanoid.getNormalizedBoneNode('leftUpperArm');
                const rightArm = vrm.humanoid.getNormalizedBoneNode('rightUpperArm');

                if (leftArm) {
                    leftArm.rotation.set(0, 0, 1.5);  // ÊâãËáÇÂêë‰∏ã
                    console.log('[OK] Left arm posed');
                }
                if (rightArm) {
                    rightArm.rotation.set(0, 0, -1.5);  // ÊâãËáÇÂêë‰∏ã
                    console.log('[OK] Right arm posed');
                }
            }

            document.getElementById('loading').style.display = 'none';
            document.getElementById('controls').style.display = 'flex';
            document.getElementById('status').style.display = 'block';
            document.getElementById('emotion-display').style.display = 'block';
            document.getElementById('debug-panel').style.display = 'block';
        });

        // Ë°®ÊÉÖÊéßÂà∂ - Â∏¶Âπ≥ÊªëËøáÊ∏°
        function setExpression(emotion, intensity = 1.0) {
            if (!vrm || !vrm.expressionManager) return;

            targetExpression = { emotion, intensity };
            expressionTransitionProgress = 0;

            // Update UI
            const emotionIcons = {
                'joy': 'üòä',
                'excited': 'ü§©',
                'sad': 'üò¢',
                'anger': 'üò†',
                'surprise': 'üò≤',
                'confused': 'ü§î',
                'embarrassed': 'üò≥',
                'determined': 'üò§',
                'relaxed': 'üòå',
                'neutral': 'üòê'
            };

            document.getElementById('emotion-text').textContent =
                emotion.charAt(0).toUpperCase() + emotion.slice(1);
            document.getElementById('emotion-icon').textContent = emotionIcons[emotion] || 'üòä';
            document.getElementById('emotion-bar-fill').style.width = (intensity * 100) + '%';
        }

        // Update expression with smooth transition
        function updateExpression(deltaTime) {
            if (!vrm || !vrm.expressionManager) return;

            // Update transition progress
            if (expressionTransitionProgress < 1.0) {
                expressionTransitionProgress = Math.min(1.0, expressionTransitionProgress + deltaTime * EXPRESSION_TRANSITION_SPEED);
            }

            // Interpolate between current and target
            const t = easeInOutCubic(expressionTransitionProgress);
            const blendedIntensity = currentExpression.intensity * (1 - t) + targetExpression.intensity * t;

            // Apply expression
            const expressionName = EMOTION_MAP[targetExpression.emotion] || 'neutral';

            try {
                // Clear all expressions
                vrm.expressionManager.setValue('happy', 0);
                vrm.expressionManager.setValue('sad', 0);
                vrm.expressionManager.setValue('angry', 0);
                vrm.expressionManager.setValue('surprised', 0);
                vrm.expressionManager.setValue('neutral', 0);
                if (vrm.expressionManager.getValue('relaxed') !== undefined) {
                    vrm.expressionManager.setValue('relaxed', 0);
                }

                // Set target expression
                vrm.expressionManager.setValue(expressionName, blendedIntensity);

                // Update current if transition complete
                if (expressionTransitionProgress >= 1.0) {
                    currentExpression = { ...targetExpression };
                }
            } catch (error) {
                console.error('[ERROR] Expression update:', error);
            }
        }

        // Easing function for smooth transitions
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // Blink system
        function updateBlink(deltaTime) {
            if (!vrm || !vrm.expressionManager) return;

            if (isBlinking) {
                blinkProgress += deltaTime * 10; // Blink speed
                if (blinkProgress >= 1.0) {
                    isBlinking = false;
                    blinkProgress = 0;
                    lastBlinkTime = time;
                    nextBlinkDelay = 2.0 + Math.random() * 3.0; // Random delay 2-5s
                }

                // Apply blink
                const blinkValue = Math.sin(blinkProgress * Math.PI);
                try {
                    vrm.expressionManager.setValue('blink', blinkValue);
                } catch (e) {
                    // Blink blend shape might not exist
                }
            } else {
                // Check if time to blink
                if (time - lastBlinkTime > nextBlinkDelay) {
                    isBlinking = true;
                    blinkProgress = 0;
                }
            }
        }

        // Âò¥ÂûãÊéßÂà∂
        function setViseme(viseme, weight = 1.0) {
            if (!vrm || !vrm.expressionManager) return;

            const visemeMap = { 'A': 'aa', 'E': 'ee', 'I': 'ih', 'O': 'oh', 'U': 'ou' };
            const vrmViseme = visemeMap[viseme] || 'aa';

            try {
                Object.values(visemeMap).forEach(v => {
                    vrm.expressionManager.setValue(v, 0);
                });
                vrm.expressionManager.setValue(vrmViseme, weight);
            } catch (error) {}
        }

        // WebSocket
        function connectWebSocket() {
            if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;

            ws = new WebSocket('ws://localhost:8000/ws');

            ws.onopen = () => {
                console.log('[OK] WebSocket connected');
                updateStatus('connected', 'Ready');
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);

                if (data.type === 'emotion') {
                    setExpression(data.emotion, data.intensity || 1.0);
                }
                if (data.type === 'audio') {
                    playAudio(data.audio);
                }
                if (data.type === 'gesture' && data.gesture) {
                    playGesture(data.gesture);
                }
            };

            ws.onerror = (error) => {
                console.error('[ERROR] WebSocket:', error);
                updateStatus('disconnected', 'Error');
            };

            ws.onclose = () => {
                updateStatus('disconnected', 'Disconnected');
                ws = null;
                setTimeout(connectWebSocket, 3000);
            };
        }

        function updateStatus(status, text) {
            const statusDot = document.querySelector('.status-dot');
            const statusText = document.getElementById('status-text');

            statusDot.className = 'status-dot';
            if (status === 'connected') statusDot.classList.add('status-connected');
            else if (status === 'thinking') statusDot.classList.add('status-thinking');
            else statusDot.classList.add('status-disconnected');

            statusText.textContent = text;
        }

        // Èü≥È¢ëÊí≠Êîæ
        async function playAudio(audioBase64) {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            stopMouth(); // Stop any existing mouth animation

            try {
                const audioData = atob(audioBase64);
                const arrayBuffer = new ArrayBuffer(audioData.length);
                const view = new Uint8Array(arrayBuffer);
                for (let i = 0; i < audioData.length; i++) {
                    view[i] = audioData.charCodeAt(i);
                }

                const blob = new Blob([arrayBuffer], { type: 'audio/wav' });
                const audioUrl = URL.createObjectURL(blob);
                currentAudio = new Audio(audioUrl);

                // IMPORTANT: Only start mouth animation AFTER audio actually starts playing
                currentAudio.addEventListener('playing', () => {
                    console.log('[Audio] Started playing');
                    animateMouth();
                });

                currentAudio.addEventListener('ended', () => {
                    console.log('[Audio] Finished');
                    stopMouth();
                    updateStatus('connected', 'Ready');
                });

                currentAudio.addEventListener('error', (e) => {
                    console.error('[ERROR] Audio playback failed:', e);
                    stopMouth();
                    updateStatus('connected', 'Ready');
                });

                // Start playback
                await currentAudio.play();
            } catch (error) {
                console.error('[ERROR] Audio:', error);
                stopMouth();
                updateStatus('connected', 'Ready');
            }
        }

        let mouthAnimationFrame = null;
        function animateMouth() {
            const visemes = ['A', 'I', 'U', 'E', 'O'];
            let index = 0;
            function animate() {
                setViseme(visemes[index], 0.7);
                index = (index + 1) % visemes.length;
                mouthAnimationFrame = setTimeout(animate, 100);
            }
            animate();
        }

        function stopMouth() {
            if (mouthAnimationFrame) {
                clearTimeout(mouthAnimationFrame);
                mouthAnimationFrame = null;
            }
            setViseme('A', 0);
        }

        // Gesture system
        let currentGesture = null;
        let gestureProgress = 0;

        function playGesture(gesture) {
            if (!vrm || !vrm.humanoid) return;

            currentGesture = gesture;
            gestureProgress = 0;
            console.log('[Gesture]', gesture);
        }

        function updateGesture(deltaTime) {
            if (!currentGesture || !vrm || !vrm.humanoid) {
                document.getElementById('debug-gesture').textContent = 'none';
                return;
            }

            gestureProgress += deltaTime * 1.5; // Slower, more natural speed

            const leftArm = vrm.humanoid.getNormalizedBoneNode('leftUpperArm');
            const rightArm = vrm.humanoid.getNormalizedBoneNode('rightUpperArm');
            const leftLowerArm = vrm.humanoid.getNormalizedBoneNode('leftLowerArm');
            const rightLowerArm = vrm.humanoid.getNormalizedBoneNode('rightLowerArm');
            const head = vrm.humanoid.getNormalizedBoneNode('head');

            // Update debug display
            document.getElementById('debug-gesture').textContent = currentGesture;
            document.getElementById('debug-progress').textContent = gestureProgress.toFixed(2);

            const t = Math.min(1.0, gestureProgress / 1.5); // Normalize to gesture duration
            const easeIn = easeInOutCubic(t);
            const easeOut = easeInOutCubic(Math.max(0, (gestureProgress - 1.5) / 0.5)); // Ease out phase

            try {
                switch(currentGesture) {
                    case 'wave':
                        // Simple wave: small side-to-side motion
                        if (rightArm) {
                            const wave = Math.sin(gestureProgress * 8) * 0.3;
                            rightArm.rotation.set(
                                0,
                                0,
                                -1.3 + wave * (1 - easeOut)
                            );
                        }
                        break;

                    case 'nod':
                        // Simple nod: 2 nods
                        if (head) {
                            const nods = Math.sin(gestureProgress * 5) * 0.2;
                            head.rotation.x = nods * (1 - easeOut);
                            head.rotation.y = 0;
                            head.rotation.z = 0;
                        }
                        break;

                    case 'shake_head':
                        // Simple head shake: 2 shakes
                        if (head) {
                            const shakes = Math.sin(gestureProgress * 6) * 0.25;
                            head.rotation.x = 0;
                            head.rotation.y = shakes * (1 - easeOut);
                            head.rotation.z = 0;
                        }
                        break;

                    case 'think':
                        // Thinking: slight tilt
                        if (head) {
                            head.rotation.x = -0.15 * easeIn;
                            head.rotation.y = 0.1 * easeIn;
                            head.rotation.z = 0;
                        }
                        break;

                    case 'celebrate':
                        // Celebrate: small bounce
                        if (head) {
                            const bounce = Math.sin(gestureProgress * 6) * 0.1;
                            head.rotation.x = bounce;
                            head.rotation.y = 0;
                            head.rotation.z = 0;
                        }
                        break;

                    default:
                        // No gesture, clear it
                        currentGesture = null;
                        gestureProgress = 0;
                        return;
                }

                // Update debug info
                if (rightArm) {
                    document.getElementById('debug-rarm').textContent =
                        `${rightArm.rotation.x.toFixed(2)}, ${rightArm.rotation.y.toFixed(2)}, ${rightArm.rotation.z.toFixed(2)}`;
                }
                if (leftArm) {
                    document.getElementById('debug-larm').textContent =
                        `${leftArm.rotation.x.toFixed(2)}, ${leftArm.rotation.y.toFixed(2)}, ${leftArm.rotation.z.toFixed(2)}`;
                }
                if (head) {
                    document.getElementById('debug-head').textContent =
                        `${head.rotation.x.toFixed(2)}, ${head.rotation.y.toFixed(2)}, ${head.rotation.z.toFixed(2)}`;
                }

                // Reset gesture after complete animation (2 seconds)
                if (gestureProgress > 2.0) {
                    currentGesture = null;
                    gestureProgress = 0;
                }
            } catch (error) {
                console.error('[ERROR] Gesture:', error);
                currentGesture = null;
            }
        }

        // ËØ≠Èü≥ËØÜÂà´
        function initSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                document.getElementById('mic-status').textContent = 'Not supported';
                return;
            }

            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'zh-CN';

            recognition.onstart = () => {
                isListening = true;
                document.getElementById('talk-btn').classList.add('recording');
                document.getElementById('mic-status').textContent = 'Listening...';
                updateStatus('thinking', 'Listening...');
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                sendTextToAI(transcript);
            };

            recognition.onerror = (event) => {
                console.error('[ERROR] Speech:', event.error);
                updateStatus('connected', 'Ready');
                isListening = false;
                document.getElementById('talk-btn').classList.remove('recording');
            };

            recognition.onend = () => {
                isListening = false;
                document.getElementById('talk-btn').classList.remove('recording');
                document.getElementById('mic-status').textContent = 'Click and speak';
            };
        }

        function sendTextToAI(text) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                console.error('[ERROR] WebSocket not connected');
                updateStatus('disconnected', 'Not connected');
                return;
            }

            updateStatus('thinking', 'Thinking...');
            ws.send(JSON.stringify({ type: 'user_input', text: text }));
        }

        // ÊåâÈíÆ‰∫ã‰ª∂
        document.getElementById('talk-btn').addEventListener('mousedown', () => {
            if (recognition && !isListening) {
                try { recognition.start(); } catch (error) { console.error(error); }
            }
        });

        document.getElementById('talk-btn').addEventListener('mouseup', () => {
            if (recognition && isListening) recognition.stop();
        });

        // Âä®ÁîªÂæ™ÁéØ
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            time += delta;

            if (vrm) {
                vrm.update(delta);

                // Update expression transition
                updateExpression(delta);

                // Update blink system
                updateBlink(delta);

                // Update gesture animation
                updateGesture(delta);

                // ÂëºÂê∏ÂíåËá™ÁÑ∂Âä®‰Ωú (only if no gesture playing)
                if (vrm.humanoid) {
                    const chest = vrm.humanoid.getNormalizedBoneNode('chest');
                    if (chest && !currentGesture) {
                        chest.rotation.x = Math.sin(time * 1.5) * 0.02;
                    }

                    const head = vrm.humanoid.getNormalizedBoneNode('head');
                    if (head && !currentGesture) {
                        head.rotation.y = Math.sin(time * 0.35) * 0.05;
                        head.rotation.z = Math.cos(time * 0.28) * 0.03;
                    }

                    // ONLY apply idle arm animation when NO gesture is playing
                    if (!currentGesture) {
                        const leftArm = vrm.humanoid.getNormalizedBoneNode('leftUpperArm');
                        const rightArm = vrm.humanoid.getNormalizedBoneNode('rightUpperArm');

                        if (leftArm) {
                            leftArm.rotation.set(
                                Math.sin(time * 0.8) * 0.05,
                                0,
                                1.5 + Math.sin(time * 0.6) * 0.03
                            );
                        }

                        if (rightArm) {
                            rightArm.rotation.set(
                                Math.sin(time * 0.8 + Math.PI) * 0.05,
                                0,
                                -1.5 - Math.sin(time * 0.6) * 0.03
                            );
                        }
                    }
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // ÂêØÂä®
        window.addEventListener('load', () => {
            initSpeechRecognition();
            connectWebSocket();
            animate();
        });

        // Ë∞ÉËØïÊé•Âè£
        window.ani = {
            setExpression,
            sendText: sendTextToAI,
            vrm: () => vrm
        };
    </script>
</body>
</html>
